<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acquisition Analyser v0.5</title>
    <style>
        /* --- Styles (Updated Summary Style) --- */
        body { font-family: sans-serif; line-height: 1.6; margin: 20px; background-color: rgb(230, 255, 0); color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); max-width: 1200px; margin: auto; }
        #logo { max-width: 200px; height: auto; display: block; margin: 0 auto 20px auto; }
        h1, h2, h3 { color: #2c3e50; text-align: center; }
        h2, h3 { text-align: left; }
        details { background-color: #ecf0f1; border: 1px solid #bdc3c7; border-radius: 4px; margin-bottom: 10px; padding: 10px; }
        summary {
            font-weight: bold;
            cursor: pointer;
            color: #34495e;
            display: block; /* Added to potentially fix rendering issues */
        }
        /* Ensure marker doesn't get hidden if summary itself has issues */
        summary::marker { color: #34495e; }
        summary:focus { outline: 2px solid #3498db; outline-offset: 2px; } /* Basic focus style */

        .factor-explanation p { margin-left: 15px; font-size: 0.9em; color: #555; margin-top: 5px; } /* Added margin-top */
        .factor-explanation strong { color: #34495e; }
        .upload-section, .weights-section, .analysis-section, .results-section { margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="file"] { margin-bottom: 15px; padding: 8px 10px; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; }
        button#analyzeButton { background-color: #e6ff00; color: #000000; border: 1px solid #b3cc00; padding: 15px 30px; border-radius: 5px; cursor: pointer; font-size: 1.1em; transition: background-color 0.3s ease, border-color 0.3s ease; }
        button#analyzeButton:hover { background-color: #d1e600; border-color: #99a300; }
        button#analyzeButton:disabled { background-color: #d8d8d8; color: #888888; border-color: #cccccc; cursor: not-allowed; }
        .slider-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .slider-item { display: flex; flex-direction: column; }
        .slider-item label { font-size: 0.9em; margin-bottom: 3px; }
        .slider-item input[type="range"] { width: 100%; }
        .slider-item span { font-size: 0.8em; text-align: right; color: #7f8c8d; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 0.9em; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #ecf0f1; color: #34495e; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        tbody tr:hover { background-color: #e0e0e0; cursor: default; }
        .rank-1 { background-color: #e6ff00; } .rank-2 { background-color: #dced0f; } .rank-3 { background-color: #c2d91e; } .rank-4 { background-color: #a8c62c; } .rank-5 { background-color: #8eb33b; }
        .rank-1 td, .rank-2 td, .rank-3 td, .rank-4 td, .rank-5 td { border-bottom: 1px solid rgba(0,0,0,0.1); border-top: 1px solid rgba(255,255,255,0.2); }
        #error-log { margin-top: 15px; }
        #loading { display: none; margin: 15px 0; font-style: italic; color: #3498db; }
        #csvSample { background-color: #f8f8f8; border: 1px dashed #ccc; padding: 10px; margin-top: 10px; font-family: monospace; white-space: pre; overflow-x: auto; font-size: 0.8em; max-height: 200px; }
    </style>
</head>
<body>
    <div class="container">
        <img id="logo" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgoAAADkCAYAAAD5EAyOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAHYcAAB2HAY/l8WUAAFxnSURBVHhe7Z0J/FTj98evLXuFX5YUlZA2FSqSNpLsSouiRGSJX5IiRCkttiylRZKlVWXfFUURUaRfGwmlxU8pWX7+7v++jzvMd3ruzJ3t3pn5nvfr9dDMd+6dO3d5nvOc55zP2cl2sBRFURRFUQzs7P5fURRFURRlB9RQUBRFURTFEzUUFEVRFEXxRA0FRVEURVE8UUNBURRFURRP1FBQFEVRFMUTNRQURVEURfFEDQVFURRFUTxRQ0FRFEVRFE/UUFAURVEUxRM1FBRFURRF8UQNBUVRFEVRPFFDQVEURVEUT9RQUBRFURTFEzUUFEVRFEXxRA0FRVEURVE8UUNBURRFURRP1FBQFEVRFMUTNRQURVEURfFEDQVFURRFUTxRQ0FRFEVRFE92sh3cfysBwOneunWr9dNPP0nbvn279csvv1i//vqr9b///c/6v//7P/kM7Lzzztauu+5q7b777tYee+xh7bXXXtbee+9tlSxZ0ipdurRVokQJ+ZyipMuWLVusDz/8UO5H2GmnneT/wL9r1apllS9f3n1HUZTihBoKWeLPP/+0Nm/ebK1Zs8ZatWqV9eWXX8q/v//+e+uHH36Qv9E5b9u2zfr555/FWGAbExgEe+65p7XvvvtKw0jYb7/9rDJlykjnXaFCBevII4+U/x900EFiWChKMixcuNA655xzrO+++8595x922WUXa8yYMdall17qvqMoSnFCDYUMwClk4P/222+tL774QmZmn376qfX1119bGzduFG/B77//7n468+B5iBgS5cqVs6pXr26dcMIJ1vHHHy+GBMYDn1FyF+4hZvNBPI54CPBQYQBE4H49++yz5R6OBa/WY489Zl1yySXuO4qiFCfUUEgRZv8YAgsWLLA++OAD66OPPrI++eQTWVbIFXbbbTerSpUqVv369a26deta9erVk9e8r+QW69evt/r06SP/z6ZRx32LUdm3b1+rTp067rtqKCiK4o0aCkmAV2D16tXWW2+9Zb366qvWokWLZCnht99+cz+RuzB7ZKkCb8Opp55qnXXWWVblypV1mSJHYGnqlFNOMbr+Mw3XfPr06VbL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" alt="Evident Logo"> <h1>Acquisition Analyser v0.4</h1>

        <h2>Key Factors Influencing SaaS Valuations</h2>
        <div class="factor-explanation">
            <details>
                <summary>Social Architecture</summary>
                <p>Evaluates the company's internal structure and human elements: clarity of governance, quality and completeness of leadership & key talent, effectiveness of organizational design, and efficiency through lean processes.<br>
                   <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV (column: `VerticalFocusScore`). Normalized (higher is better). Contributes to the overall weighted 'Score' based on its slider weight. Not directly used in the simplified valuation multiple adjustment.</p>
            </details>
            <details>
                <summary>Strategy + Vision</summary>
                <p>Assesses the strength and clarity of the company's forward-looking plans: how well the vision focuses on crucial, permanent customer needs, the coherence of the product roadmap, the effectiveness of the commercial strategy (go-to-market), and the plan for leveraging ecosystem partnerships.<br>
                   <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV (column: `LeadershipScore`). Normalized (higher is better). Contributes significantly to the overall weighted 'Score' based on its slider weight. Not directly used in the simplified valuation multiple adjustment.</p>
            </details>
             <details>
                <summary>Technical Architecture</summary>
                <p>Assesses the quality, scalability, and maintainability of the company's technology foundation: quality of tech assets (codebase, infrastructure), development methodologies (Agile, DevOps), maturity of build and deployment processes (CI/CD), and adherence to a sound reference architecture.<br>
                    <strong>Implementation:</strong> Score (0-10) from CSV (column: `TechnicalDebtScore`). Normalized where *lower* input score (less debt) results in a *higher* normalized score (higher is better for analysis). Weighted in the 'Score'. Used as a minor *negative* driver (high debt reduces multiple) in valuation adjustment.</p>
            </details>
            <details>
                <summary>Operational Effectiveness</summary>
                <p>Evaluates the efficiency and execution capabilities across key business functions: clarity in defining success (KPIs, OKRs), effectiveness of the product development lifecycle, efficiency of commercial execution (sales, marketing, customer success), and robustness of risk management and compliance processes.<br>
                   <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV (column: `ProductInnovationScore`). Normalized (higher is better). Contributes to the overall weighted 'Score' based on its slider weight. Not directly used in the simplified valuation multiple adjustment.</p>
            </details>
             <details><summary>ARR (Annual Recurring Revenue)</summary><p>This is the normalized annual run-rate of recurring revenue, typically excluding one-time fees. It's the cornerstone of SaaS valuation as it represents predictable income, which investors and acquirers value highly over volatile revenue streams. The size of ARR often indicates the company's stage (startup, growth, mature) and influences the applicable valuation multiple range.<br><strong>Implementation:</strong> The tool reads the ARR value directly from your CSV. This value forms the base for the final 'Valuation Range' calculation (ARR multiplied by an adjusted multiple). It does not directly influence the weighted 'Score', but its magnitude provides context for all other metrics.</p></details>
             <details><summary>GREM (Growth Rate + EBITDA Margin)</summary><p>Often related to the "Rule of 40", this metric balances high growth (which often requires investment and can reduce margins) with profitability (EBITDA Margin). A high GREM score indicates efficient growth – the company is expanding without excessively burning cash. Scores above 40-50% are generally considered strong for mature SaaS businesses.<br><strong>Implementation:</strong> The tool calculates GREM automatically (`RevenueGrowth + EBITDA_Margin`) after parsing the CSV. This calculated GREM value is then normalized (scaled 0-1). It's used as a positive factor when adjusting the base ARR multiple in the simplified valuation calculation. You can also assign it a weight using its slider to include it directly in the overall 'Score'.</p></details>
             <details><summary>Revenue Growth Rate</summary><p>Measures the year-over-year percentage increase in ARR. High, sustainable growth signals strong product-market fit, effective sales/marketing, and a large addressable market. It's a primary driver of high valuation multiples, especially for earlier-stage companies where future potential outweighs current profitability.<br><strong>Implementation:</strong> Read from the CSV (as a decimal, e.g., 0.4 for 40%) and normalized (0-1 scale, higher is better). This normalized value significantly contributes to the overall weighted 'Score' based on its slider setting. It's also treated as a major positive driver when adjusting the ARR multiple in the valuation calculation.</p></details>
             <details><summary>Net Revenue Retention (NRR) and Gross Revenue Retention (GRR)</summary><p>NRR tracks how much recurring revenue is retained from the *existing* customer base over a period, including expansion revenue (upsells, cross-sells) but accounting for churn and contraction. NRR > 100% ("negative churn") is highly desirable, indicating growth even without new customers. GRR measures only the revenue retained, excluding expansion – it highlights fundamental customer stickiness and churn.<br><strong>Implementation:</strong> Both NRR and GRR are read from the CSV (as decimals, e.g., 1.15 for 115%) and normalized (higher is better). Both contribute to the weighted 'Score' based on their sliders. NRR, due to its reflection of expansion, also acts as a significant positive driver in adjusting the ARR multiple for valuation.</p></details>
             <details><summary>Customer Concentration</summary><p>Measures the risk associated with relying too heavily on a small number of customers. If a large portion of revenue comes from one or two clients, the loss of such a client could severely impact the business. Acquirers prefer a diversified customer base.<br><strong>Implementation:</strong> Read from the CSV (as a decimal, e.g., 0.2 for 20%). Normalized on a 0-1 scale where *lower* concentration yields a *higher* normalized score (indicating it's better). This normalized score contributes to the weighted 'Score'. High concentration (low normalized score) also acts as a *negative* driver, reducing the ARR multiple in the valuation calculation.</p></details>
             <details><summary>CAC (Customer Acquisition Cost) to LTV (Customer Lifetime Value) Ratio</summary><p>This ratio assesses the efficiency and profitability of customer acquisition efforts. LTV represents the total predicted revenue from a customer over their entire relationship with the company, while CAC is the cost to acquire that customer. A ratio significantly greater than 1 (often aiming for 3:1 or higher) indicates a sustainable business model where customer value outweighs acquisition cost.<br><strong>Implementation:</strong> Read from the CSV (expected as the LTV/CAC value itself, e.g., 4.0 for a 4:1 ratio) and normalized (higher is better). It contributes to the overall weighted 'Score' based on its slider weight. *Note: This simplified tool does not currently use LTV/CAC directly in the ARR multiple adjustment, but it's crucial for overall business health assessment.*</p></details>
             <details><summary>Market Position and Competitive Differentiation</summary> <p>Evaluates the company's standing relative to competitors. Does it have a unique technological advantage, strong brand recognition, intellectual property, high switching costs, or network effects that create a "moat"? A strong, defensible position allows for better pricing power and long-term stability.<br> <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV. Normalized (0-1 scale, higher is better). Contributes to the weighted 'Score' based on its slider. Acts as a minor positive driver when adjusting the ARR multiple in the valuation estimate, reflecting the value of a strong market standing.</p> </details>
             <details><summary>Addressable Market (TAM>SAM>SOM)</summary> <p>Evaluates the Addressable Market Size: the overall revenue opportunity available for the product or service. A large and potentially growing Addressable Market suggests ample room for future expansion, making the company more attractive to acquirers looking for significant scale.<br> <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV, reflecting the size and growth potential of the TAM. Normalized (higher is better). Contributes to the weighted 'Score' based on its slider. Acts as a minor positive driver when adjusting the ARR multiple in the valuation estimate.</p> </details>
             <details><summary>Customer Contracts and Revenue Visibility</summary> <p>Reflects the predictability and stability of future revenue streams. Longer contract terms (annual vs. monthly), high renewal rates, low churn, and clear payment terms reduce risk and make forecasting easier for potential acquirers.<br> <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV assessing contract quality and revenue predictability. Normalized (higher is better). Contributes to the overall weighted 'Score' based on its slider weight. Not directly used in the simplified valuation multiple adjustment.</p> </details>
             <details><summary>Quality of Financial Statements</summary> <p>Refers to the accuracy, transparency, and adherence to accounting standards (like GAAP/IFRS) of the company's financial records. Clean, audited (or auditable) financials build trust and streamline the due diligence process, preventing deal complications or valuation discounts.<br> <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV. Normalized (higher is better). Contributes to the weighted 'Score' based on its slider weight. Acts as a minor positive driver when adjusting the ARR multiple, reflecting reduced diligence risk.</p> </details>
             <details><summary>Cash Flow and Profitability</summary> <p>While growth is often key, underlying profitability (like positive EBITDA margin or Free Cash Flow) demonstrates business model viability and reduces reliance on external funding. A clear path to profitability, even if not yet achieved, is important.<br> <strong>Implementation:</strong> Input as a subjective score (0-10) via CSV reflecting current status and trajectory. Normalized (higher is better). Contributes to the weighted 'Score' based on its slider weight. Acts as a minor positive driver when adjusting the ARR multiple.</p> </details>

        </div>

        <div class="upload-section">
            <h2>1. Upload Company Data (.csv)</h2>
            <label for="csvFile">Select CSV File (Max 50 companies + header row):</label>
            <input type="file" id="csvFile" accept=".csv">
            <p>Expected Columns (All Required, **using internal IDs**): <code>CompanyName, ARR, EBITDA_Margin, RevenueGrowth, NRR, GRR, CustomerConcentration, CAC_LTV_Ratio, MarketPositionScore, TAM_Score, VerticalFocusScore, LeadershipScore, ProductInnovationScore, ContractVisibilityScore, FinancialQualityScore, CashFlowScore, ScalabilityScore, TechnicalDebtScore, Website, CompanyActivity, FounderName, FounderLinkedIn, MarketPotentialNotes, SynergiesNotes, ExitPotentialNotes</code></p>
            <p><small>Note: Ensure text fields containing commas are enclosed in double quotes.</small></p>
            <p><small>See Sample CSV content below (uses required internal IDs in header):</small></p>
            <pre id="csvSample">Generating sample CSV...</pre>
        </div>

        <div class="weights-section">
            <h2>2. Adjust Factor Weights</h2>
            <p>Use the sliders to set the importance of each factor (0-10). Names reflect updated definitions.</p>
            <div class="slider-container" id="sliders"></div>
        </div>

        <div class="analysis-section">
            <h2>3. Analyse Companies</h2>
            <button id="analyzeButton" disabled>Analyse</button>
            <div id="loading">Processing...</div>
            <div id="error-log"></div>
        </div>

        <div class="results-section">
            <h2>Results: Ranked Companies</h2>
            <p>Ranked companies list. Hover over a row for Activity, Website, Founder, and SWOT Notes.</p>
            <div id="resultsTableContainer"><p>Upload a CSV and click "Analyse" to see results.</p></div>
             <p><small><strong>Disclaimer:</strong> Copyright Ⓒ 2025 Philippe Van Caenegem. The Provider makes no warranties, express or implied, including but not limited to, the implied warranties of merchantability and fitness for a particular purpose. This tool and its content does not constitute financial advice and should not be used as such.</small></p>
        </div>
    </div>

    <script>
    // Wrap entire script logic in a try-catch for ultimate debugging
    try {
        // --- Constants, Globals, Factors, Columns Definitions (Updated Factors) ---
        const csvFileInput = document.getElementById('csvFile');
        const analyzeButton = document.getElementById('analyzeButton');
        const slidersContainer = document.getElementById('sliders');
        const resultsTableContainer = document.getElementById('resultsTableContainer');
        const errorLog = document.getElementById('error-log');
        const loadingIndicator = document.getElementById('loading');
        const csvSampleContainer = document.getElementById('csvSample');
        let companyData = [];
        let factorWeights = {};

        // --- Updated Factor Definitions (Names changed) ---
        const factors = [
            { id: 'ARR', name: 'ARR', weight: 8, type: 'metric', higherIsBetter: true, format: 'currency' },
            { id: 'EBITDA_Margin', name: 'EBITDA Margin', weight: 0, type: 'metric', higherIsBetter: true, format: 'percent' },
            { id: 'RevenueGrowth', name: 'Revenue Growth Rate', weight: 9, type: 'metric', higherIsBetter: true, format: 'percent' },
            { id: 'GREM', name: 'GREM (Growth+EBITDA Margin)', weight: 7, type: 'metric', higherIsBetter: true, format: 'percent' },
            { id: 'NRR', name: 'Net Revenue Retention (NRR)', weight: 8, type: 'metric', higherIsBetter: true, format: 'percent' },
            { id: 'GRR', name: 'Gross Revenue Retention (GRR)', weight: 6, type: 'metric', higherIsBetter: true, format: 'percent' },
            { id: 'CustomerConcentration', name: 'Customer Concentration', weight: 5, type: 'metric', higherIsBetter: false, format: 'percent' },
            { id: 'CAC_LTV_Ratio', name: 'CAC to LTV Ratio (LTV/CAC)', weight: 6, type: 'metric', higherIsBetter: true, format: 'number' },
            { id: 'MarketPositionScore', name: 'Market Position', weight: 7, type: 'score', higherIsBetter: true, format: 'score' },
            { id: 'TAM_Score', name: 'Addressable Market (TAM)', weight: 7, type: 'score', higherIsBetter: true, format: 'score' },
            // --- RENAMED ---
            { id: 'VerticalFocusScore', name: 'Social Architecture', weight: 5, type: 'score', higherIsBetter: true, format: 'score' },
            { id: 'LeadershipScore', name: 'Strategy + Vision', weight: 6, type: 'score', higherIsBetter: true, format: 'score' },
            { id: 'ProductInnovationScore', name: 'Operational Effectiveness', weight: 6, type: 'score', higherIsBetter: true, format: 'score' },
            // --- /RENAMED ---
            { id: 'ContractVisibilityScore', name: 'Contract/Revenue Visibility', weight: 5, type: 'score', higherIsBetter: true, format: 'score' },
            { id: 'FinancialQualityScore', name: 'Quality of Financials', weight: 7, type: 'score', higherIsBetter: true, format: 'score' },
            { id: 'CashFlowScore', name: 'Cash Flow / Profitability', weight: 6, type: 'score', higherIsBetter: true, format: 'score' },
            { id: 'ScalabilityScore', name: 'Platform Scalability', weight: 5, type: 'score', higherIsBetter: true, format: 'score' },
            // --- RENAMED ---
            // NOTE: ID remains 'TechnicalDebtScore'. CSV column must be 'TechnicalDebtScore'.
            // higherIsBetter remains false (lower score input = less debt = higher normalized value).
            // Display name shows 'Technical Architecture', but data represents INVERSE (quality = low debt).
            { id: 'TechnicalDebtScore', name: 'Technical Architecture', weight: 4, type: 'score', higherIsBetter: false, format: 'score' }
            // --- /RENAMED ---
        ];

        const expectedColumns = [
            'CompanyName', 'ARR', 'EBITDA_Margin', 'RevenueGrowth', 'NRR', 'GRR',
            'CustomerConcentration', 'CAC_LTV_Ratio', 'MarketPositionScore',
            'TAM_Score', 'VerticalFocusScore', 'LeadershipScore', // Keep original IDs
            'ProductInnovationScore', 'ContractVisibilityScore', 'FinancialQualityScore', // Keep original IDs
            'CashFlowScore', 'ScalabilityScore', 'TechnicalDebtScore', // Keep original IDs
            'Website', 'CompanyActivity', 'FounderName', 'FounderLinkedIn',
            'MarketPotentialNotes', 'SynergiesNotes', 'ExitPotentialNotes'
        ];
        const textColumns = [
            'CompanyName', 'Website', 'CompanyActivity', 'FounderName', 'FounderLinkedIn',
            'MarketPotentialNotes', 'SynergiesNotes', 'ExitPotentialNotes'
        ];

        // --- Formatting Helpers (Unchanged) ---
        const formatCurrency = (value) => typeof value !== 'number' || isNaN(value) ? 'N/A' : value >= 1000000 ? `$${(value / 1000000).toFixed(1)}M` : `$${(value / 1000).toFixed(0)}K`;
        const formatPercent = (value) => typeof value !== 'number' || isNaN(value) ? 'N/A' : `${(value * 100).toFixed(1)}%`;
        const formatNumber = (value, decimals = 1) => typeof value !== 'number' || isNaN(value) ? 'N/A' : value.toFixed(decimals);
        const formatScore = (value) => typeof value !== 'number' || isNaN(value) ? 'N/A' : `${value}/10`;

        // --- Utility: Error Logging (Enhanced) ---
        function logError(message, isError = true) {
             console[isError ? 'error' : 'info'](`User Log (${isError ? 'Error' : 'Info'}): ${message}`); // Always log to console
             try { // Try updating UI, but don't let it cause further errors
                 const msgElement = document.createElement('p');
                 msgElement.textContent = message;
                 msgElement.style.color = isError ? 'red' : 'green';
                 msgElement.style.fontWeight = isError ? 'bold' : 'normal';
                 if (errorLog && errorLog.firstChild) {
                     errorLog.insertBefore(msgElement, errorLog.firstChild);
                 } else if (errorLog) {
                     errorLog.appendChild(msgElement);
                 }
             } catch (uiError) {
                 console.error("DEBUG: Failed to write log message to UI:", uiError);
             }
          }

        // --- Initialize Sliders (Unchanged logic, relies on DOM) ---
        function initializeSliders() {
             console.log("DEBUG: initializeSliders function entered.");
             if (!slidersContainer) { console.error("DEBUG: slidersContainer element NOT FOUND!"); logError("Internal Error: Cannot find slider container (#sliders).", true); return; }
             slidersContainer.innerHTML = ''; // Clear
             // Factors used for weighting (excluding ARR, EBITDA_Margin, GREM)
             const weightedFactors = factors.filter(f => f.id !== 'ARR' && f.id !== 'EBITDA_Margin' && f.id !== 'GREM');
             if (weightedFactors.length === 0) { console.warn("DEBUG: No factors configured for sliders!"); return; }
             console.log(`DEBUG: Found ${weightedFactors.length} factors for sliders. Creating...`);
             factorWeights = {}; // Reset weights
             weightedFactors.forEach((factor, index) => {
                 // console.log(`DEBUG: Creating slider ${index + 1}: ${factor.id}`); // Verbose
                 const sliderItem = document.createElement('div'); sliderItem.classList.add('slider-item');
                 const label = document.createElement('label'); label.setAttribute('for', `slider-${factor.id}`); label.textContent = factor.name; // Use updated name
                 const slider = document.createElement('input'); slider.setAttribute('type', 'range'); slider.setAttribute('id', `slider-${factor.id}`); slider.setAttribute('min', '0'); slider.setAttribute('max', '10'); slider.setAttribute('value', factor.weight); slider.dataset.factorId = factor.id;
                 const valueSpan = document.createElement('span'); valueSpan.setAttribute('id', `value-${factor.id}`); valueSpan.textContent = factor.weight;
                 slider.addEventListener('input', (event) => {
                     const weight = event.target.value; valueSpan.textContent = weight; factorWeights[event.target.dataset.factorId] = parseInt(weight, 10);
                 });
                 sliderItem.appendChild(label); sliderItem.appendChild(slider); sliderItem.appendChild(valueSpan);
                 slidersContainer.appendChild(sliderItem);
                 factorWeights[factor.id] = factor.weight; // Initialize with default weight
             });
             console.log("DEBUG: Sliders successfully created and appended.");
             console.log("DEBUG: Initial factorWeights:", JSON.stringify(factorWeights));
         }

        // --- Event Listeners (Setup moved to DOMContentLoaded) ---

        // --- File Handling & Parsing (Simplified Parser, More Logs) ---
        function handleFileSelect(event) {
             console.log("DEBUG: handleFileSelect triggered.");
             errorLog.innerHTML = ''; resultsTableContainer.innerHTML = '<p>Ready to analyse...</p>'; companyData = []; analyzeButton.disabled = true;
             const file = event.target.files[0];
             if (!file) { console.log("DEBUG: No file selected."); return; }
             console.log(`DEBUG: File selected: ${file.name}`);
             const reader = new FileReader();
             reader.onload = function(e) {
                 try {
                     console.log("DEBUG: FileReader onload - attempting parseCSV.");
                     const text = e.target.result;
                     parseCSV(text); // Use the SIMPLIFIED parser
                     console.log(`DEBUG: parseCSV completed. ${companyData.length} companies in memory.`);
                     if (companyData.length > 0 && companyData.length <= 50) {
                         logError(`Successfully loaded ${companyData.length} companies.`, false); analyzeButton.disabled = false;
                     } else if (companyData.length > 50) {
                         logError(`Error: Too many companies (${companyData.length}). Max 50.`, true); companyData = []; analyzeButton.disabled = true;
                     } else {
                         logError("No valid company data rows processed. Check CSV format/content and required header IDs.", true); analyzeButton.disabled = true;
                     }
                 } catch (error) {
                     logError(`Error processing CSV: ${error.message}`, true); console.error("DEBUG: CSV Handling Error caught in onload:", error); companyData = []; analyzeButton.disabled = true;
                 }
             };
             reader.onerror = function() { logError("Error reading file.", true); console.error("DEBUG: FileReader Error:", reader.error); analyzeButton.disabled = true; }
             reader.readAsText(file);
         }

        /**
         * Simplified CSV Parser - Handles basic quoting for commas.
         * Assumes no newlines within fields. Less robust than regex but easier to debug.
         */
        function parseCsvSimple(csvText) {
             console.log("DEBUG: parseCsvSimple entered.");
             const lines = csvText.trim().split(/\r\n|\n/); // Split into lines
             if (lines.length < 1) return { header: [], data: [] };

             // Parse Header (simple split, assumes no quotes in header)
             const header = lines[0].split(',').map(h => h.trim());
             console.log("DEBUG: Simple Header Parse:", header);
             if (header.length === 0 || header.every(h => !h)) {
                 throw new Error("CSV Header row is empty or could not be parsed.");
             }

             const data = [];
             // Regex to split fields, handling basic quotes
             const fieldRegex = /("([^"]*(?:""[^"]*)*)"|([^",]*))(?:,|$)/g;

             for (let i = 1; i < lines.length; i++) {
                 if (!lines[i]) continue; // Skip empty lines
                 const line = lines[i];
                 const currentLine = [];
                 let match;
                 fieldRegex.lastIndex = 0; // Reset regex state for each line

                 // console.log(`DEBUG: Processing Line ${i+1}: ${line.substring(0, 50)}...`); // Log start of line
                 while ((match = fieldRegex.exec(line)) !== null) {
                     let value;
                     if (match[2] !== undefined) { // Quoted field content (Group 2)
                         value = match[2].replace(/""/g, '"'); // Handle escaped double quotes
                     } else { // Unquoted field content (Group 3)
                         value = match[3];
                     }
                     // Ensure value is string and trim
                     currentLine.push(String(value || "").trim());

                     // Check if the regex stopped at the end of the line
                      if (fieldRegex.lastIndex === line.length) {
                          // If the line ended with a delimiter, the regex might match an empty field after it
                          if (line.endsWith(',')) {
                               currentLine.push("");
                          }
                          break; // End of line reached
                      }
                 }

                 // console.log(`DEBUG: Parsed Line ${i+1} fields:`, currentLine); // Log parsed fields

                 // Validate column count for the parsed line
                 if (currentLine.length === header.length) {
                     data.push(currentLine);
                 } else {
                     logError(`Warning: Row ${i+1} skipped. Column count mismatch (${currentLine.length} vs header ${header.length}). Line: "${lines[i].substring(0,100)}..."`, false);
                     console.warn(`DEBUG: Row ${i+1} column count mismatch:`, currentLine);
                 }
             }
             console.log(`DEBUG: parseCsvSimple finished. Found ${data.length} data rows.`);
             return { header, data };
         }


        function parseCSV(text) {
             companyData = []; // Reset
             console.log("DEBUG: Starting parseCSV with SIMPLE parser.");
             const { header, data: rows } = parseCsvSimple(text);

             if (!header || header.length === 0) throw new Error("Could not parse CSV header.");
             if (rows.length === 0) throw new Error("CSV contains no valid data rows.");
             console.log(`DEBUG: Simple parser found ${header.length} cols, ${rows.length} rows.`);

             // --- Validate Header Columns (Case-Insensitive CHECK against expected IDs) ---
              const lowerCaseHeader = header.map(h => h.toLowerCase());
              const missingColumns = expectedColumns.filter(colId => !lowerCaseHeader.includes(colId.toLowerCase()));
              if (missingColumns.length > 0) {
                 // Check if the user used the *new names* instead of the required IDs in the header
                 const renamedFactorIds = ['VerticalFocusScore', 'LeadershipScore', 'ProductInnovationScore', 'TechnicalDebtScore'];
                 const newNamesUsedInHeader = factors
                    .filter(f => renamedFactorIds.includes(f.id))
                    .map(f => f.name.toLowerCase()) // Get new names
                    .filter(newName => lowerCaseHeader.includes(newName)); // Check if present in header

                let errorMsg = `Missing required CSV columns (use internal IDs): ${missingColumns.join(', ')}. Check spelling/case.`;
                if (newNamesUsedInHeader.length > 0) {
                    errorMsg += ` It looks like you might have used the new display names (${newNamesUsedInHeader.join(', ')}) in the header instead of the required internal IDs (${renamedFactorIds.filter(id => factors.find(f=>f.id===id && newNamesUsedInHeader.includes(f.name.toLowerCase()))).join(', ')}). Please use the internal IDs in the CSV header.`
                }
                 throw new Error(errorMsg);
              }

             // --- Create Index Map (Case-Insensitive Key based on header) ---
             const headerIndexMap = header.reduce((acc, col, index) => { acc[col.toLowerCase()] = index; return acc; }, {});
             console.log("DEBUG: Header index map created.");

             // --- Process Data Rows ---
             let processedCount = 0;
             let skippedRowCount = 0;
             for (let i = 0; i < rows.length; i++) {
                 const cells = rows[i];
                 const rowIndexForUser = i + 2; // Account for header row (1-based index for user)

                 if (processedCount >= 50) { logError(`Warning: Only first 50 valid data rows processed.`, false); break; }

                 const company = {};
                 let rowHasFatalError = false;
                 for (const colNameId of expectedColumns) { // Iterate using expected IDs
                     const index = headerIndexMap[colNameId.toLowerCase()]; // Find index using ID
                     if (index === undefined) { // Should not happen if header validation passed, but safety check
                         console.error(`DEBUG: FATAL - Index missing for "${colNameId}" row ${rowIndexForUser}. Header validation failed?`);
                         rowHasFatalError = true;
                         break;
                     }
                     const rawValue = cells[index] !== undefined ? String(cells[index]).trim() : '';

                     const isTextField = textColumns.includes(colNameId);
                     if (isTextField) {
                         if (colNameId === 'CompanyName' && !rawValue) {
                             logError(`Warning: Row ${rowIndexForUser} missing CompanyName. Skipping.`, false); rowHasFatalError = true; break;
                         }
                         company[colNameId] = rawValue;
                     } else { // Numeric/Score
                         const cleanedValue = rawValue.replace(/[^0-9.\-]/g, '');
                         const numValue = parseFloat(cleanedValue);
                         if (rawValue === '' || isNaN(numValue)) {
                             logError(`Warning: Row ${rowIndexForUser}, Col "${colNameId}" invalid number ("${rawValue}"). Using 0.`, false);
                             company[colNameId] = 0;
                         } else {
                            // Handle percentage conversion for specific columns (input as 50 or 0.5)
                             if (['EBITDA_Margin', 'RevenueGrowth', 'NRR', 'GRR', 'CustomerConcentration'].includes(colNameId)) {
                                 // If value is likely entered as percentage (e.g., > 1.5 or <-1.5, up to 200), convert to decimal
                                 company[colNameId] = Math.abs(numValue) > 1.5 && Math.abs(numValue) <= 200 ? numValue / 100.0 : numValue;
                             } else {
                                 company[colNameId] = numValue;
                             }
                         }
                     }
                 } // End column loop

                 if (!rowHasFatalError) {
                     // Calculate GREM after processing Growth and Margin
                     const growth = company['RevenueGrowth']; const margin = company['EBITDA_Margin'];
                     company['GREM'] = (typeof growth === 'number' ? growth : 0) + (typeof margin === 'number' ? margin : 0);

                     companyData.push(company);
                     processedCount++;
                 } else {
                     skippedRowCount++;
                 }
             } // End row loop

             console.log(`DEBUG: Finished processing CSV. ${processedCount} companies loaded, ${skippedRowCount} rows skipped.`);
             if (processedCount === 0 && rows.length > 0) {
                  throw new Error("No valid company data rows could be processed. Check warnings and CSV header IDs.");
              }
          }


        // --- Analysis Logic (Unchanged) ---
        function runAnalysis() { /* ... Logic Unchanged ... */ console.log("DEBUG: Run Analysis triggered."); if (companyData.length === 0) { logError("No company data loaded or data is invalid. Cannot analyse.", true); console.warn("DEBUG: Analysis stopped: companyData is empty."); return; } errorLog.innerHTML = ''; loadingIndicator.style.display = 'block'; analyzeButton.disabled = true; setTimeout(() => { try { console.log("DEBUG: Starting data normalization..."); const normalizedData = normalizeData(companyData); console.log("DEBUG: Normalization complete."); const scoredData = calculateScores(normalizedData, factorWeights); console.log("DEBUG: Score calculation complete."); const valuedData = calculateValuationRanges(scoredData); console.log("DEBUG: Valuation estimation complete."); const rankedData = rankCompanies(valuedData); console.log("DEBUG: Ranking complete."); if (!rankedData || rankedData.length === 0) { console.warn("DEBUG: rankedData is empty or invalid before displayResults."); logError("Analysis completed, but no ranked data was generated to display.", true); } else { displayResults(rankedData); } console.log("DEBUG: Analysis complete."); } catch (error) { logError(`Analysis Error: ${error.message}`, true); console.error("DEBUG: Analysis Runtime Error:", error); resultsTableContainer.innerHTML = '<p>An error occurred during analysis. Check console (F12).</p>'; } finally { loadingIndicator.style.display = 'none'; analyzeButton.disabled = companyData.length === 0; } }, 50); }
        function normalizeData(data) { /* ... Logic Unchanged ... */ console.log("DEBUG: Normalizing factors..."); const normalized = JSON.parse(JSON.stringify(data)); const numericFactorIds = factors.map(f => f.id); numericFactorIds.forEach(factorId => { const factorInfo = factors.find(f => f.id === factorId); if (!factorInfo) return; const values = data.map(c => c[factorId]).filter(v => typeof v === 'number' && !isNaN(v)); if (values.length === 0) { console.warn(`DEBUG: No numeric values for normalization: ${factorId}. Defaulting to 0.5.`); normalized.forEach(company => { company[`${factorId}_norm`] = 0.5; }); return; }; const min = Math.min(...values); const max = Math.max(...values); const range = max - min; normalized.forEach(company => { const value = company[factorId]; let normValue = 0.5; if (typeof value === 'number' && !isNaN(value)) { if (range > 0) { normValue = factorInfo.higherIsBetter ? (value - min) / range : (max - value) / range; } else { /* Handle case where all values are the same */ normValue = 0.5; /* Or assign 1 if higherIsBetter, 0 otherwise? Let's stick to 0.5 for single value case */ } } company[`${factorId}_norm`] = Math.max(0, Math.min(1, normValue)); }); }); return normalized; }
        function calculateScores(normalizedData, weights) { /* ... Logic Unchanged ... */ console.log("DEBUG: Calculating scores with weights:", weights); let totalWeight = 0; const activeWeights = {}; Object.keys(weights).forEach(factorId => { const weightValue = weights[factorId]; if (weightValue > 0) { activeWeights[factorId] = weightValue; totalWeight += weightValue; } }); const useEqualWeight = totalWeight === 0; if (useEqualWeight) { logError("Warning: All factor weights are zero. Using equal weighting.", false); console.warn("DEBUG: Using equal weight."); const numWeightedFactors = factors.filter(f => f.id !== 'ARR' && f.id !== 'EBITDA_Margin' && f.id !== 'GREM').length; totalWeight = numWeightedFactors > 0 ? numWeightedFactors : 1; } normalizedData.forEach(company => { let weightedScoreSum = 0; let currentTotalWeight = 0; factors.filter(f => f.id !== 'ARR' && f.id !== 'EBITDA_Margin' && f.id !== 'GREM').forEach(factor => { const factorId = factor.id; const normValueKey = `${factorId}_norm`; if (company.hasOwnProperty(normValueKey)) { const weight = useEqualWeight ? 1 : (weights[factorId] || 0); if (weight > 0) { weightedScoreSum += (company[normValueKey] * weight); currentTotalWeight += weight; } } }); company.score = currentTotalWeight > 0 ? (weightedScoreSum / currentTotalWeight) * 100 : 0; }); return normalizedData; }
        function calculateValuationRanges(scoredData) { /* ... Logic Unchanged ... */ console.log("DEBUG: Calculating valuation ranges..."); const BASE_MULTIPLE_LOW = 4.0; const BASE_MULTIPLE_HIGH = 8.0; const MULTIPLE_RANGE_SPREAD = BASE_MULTIPLE_HIGH - BASE_MULTIPLE_LOW; const MAX_ADJUSTMENT_FACTOR = 3.0; scoredData.forEach(company => { let adjustmentScore = 0; let adjustmentWeightSum = 0; const valuationDrivers = [ { id: 'RevenueGrowth', weight: 3 }, { id: 'NRR', weight: 3 }, { id: 'GREM', weight: 2 }, { id: 'MarketPositionScore', weight: 1 }, { id: 'TAM_Score', weight: 1 }, { id: 'FinancialQualityScore', weight: 1 }, { id: 'CashFlowScore', weight: 1 }, { id: 'CustomerConcentration', weight: -1 }, // Higher score (lower concentration) is good, but normalized value is used. Weight is negative for *high* concentration (low norm score)
            { id: 'TechnicalDebtScore', weight: -0.5 } // Higher score (less debt) is good. Weight is negative for *high* debt (low norm score)
             ]; valuationDrivers.forEach(driver => { const normValueKey = `${driver.id}_norm`; if (company.hasOwnProperty(normValueKey)) { // Adjustment is based on deviation from the midpoint (0.5)
                // For positive weights: score > 0.5 increases multiple
                // For negative weights: score < 0.5 increases multiple (less bad = good)
                adjustmentScore += (company[normValueKey] - 0.5) * driver.weight; adjustmentWeightSum += Math.abs(driver.weight); } }); let normalizedAdjustment = 0; if (adjustmentWeightSum > 0) { normalizedAdjustment = Math.max(-1, Math.min(1, (adjustmentScore / (0.5 * adjustmentWeightSum)))); // Normalize based on max possible deviation score
             } const multipleAdjustment = normalizedAdjustment * MAX_ADJUSTMENT_FACTOR; let finalMultipleLow = BASE_MULTIPLE_LOW + multipleAdjustment - (MULTIPLE_RANGE_SPREAD / 4); let finalMultipleHigh = BASE_MULTIPLE_HIGH + multipleAdjustment + (MULTIPLE_RANGE_SPREAD / 4); finalMultipleLow = Math.max(1.0, finalMultipleLow); finalMultipleHigh = Math.max(finalMultipleLow + 0.5, finalMultipleHigh); const valuationLow = company.ARR * finalMultipleLow; const valuationHigh = company.ARR * finalMultipleHigh; company.valuationRange = { low: valuationLow, high: valuationHigh, multipleLow: finalMultipleLow, multipleHigh: finalMultipleHigh }; }); return scoredData; }
        function rankCompanies(scoredData) { /* ... Logic Unchanged ... */ console.log("DEBUG: Ranking companies..."); const sortedData = scoredData.sort((a, b) => b.score - a.score); const numCompanies = sortedData.length; if (numCompanies === 0) return sortedData; const rankSize = Math.max(1, Math.ceil(numCompanies / 5)); sortedData.forEach((company, index) => { company.rank = Math.min(5, Math.floor(index / rankSize) + 1); }); return sortedData; }

        // --- Display Results (Defensive Checks Unchanged) ---
        function displayResults(rankedData) { /* ... Logic Unchanged ... */ console.log("DEBUG: Displaying results table..."); resultsTableContainer.innerHTML = ''; if (!rankedData || rankedData.length === 0) { resultsTableContainer.innerHTML = '<p>No companies to display.</p>'; console.warn("DEBUG: displayResults called with empty data."); return; } const table = document.createElement('table'); const thead = document.createElement('thead'); const tbody = document.createElement('tbody'); const headerRow = document.createElement('tr'); const headers = ['Rank', 'Company Name', 'Score', 'ARR', 'Growth', 'NRR', 'GREM', 'Valuation Range (ARR Multiple)']; headers.forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); }); thead.appendChild(headerRow); const formatMultiple = (value) => typeof value !== 'number' || isNaN(value) ? 'N/A' : `${value.toFixed(1)}x`; const formatValuation = (range) => range ? `${formatCurrency(range.low)} - ${formatCurrency(range.high)} (${formatMultiple(range.multipleLow)} - ${formatMultiple(range.multipleHigh)})` : 'N/A'; rankedData.forEach((company, index) => { try { const row = document.createElement('tr'); row.classList.add(`rank-${company.rank}`); const tooltipDetails = []; tooltipDetails.push(`--- ${company.CompanyName || 'N/A'} ---`); if (company.CompanyActivity) tooltipDetails.push(`Activity: ${company.CompanyActivity}`); if (company.Website) tooltipDetails.push(`Website: ${company.Website}`); if (company.FounderName) { let founderInfo = `Founder: ${company.FounderName}`; if (company.FounderLinkedIn) { founderInfo += ` (LinkedIn: ${company.FounderLinkedIn})`; } tooltipDetails.push(founderInfo); } tooltipDetails.push("--- Analyst Notes ---"); if (company.MarketPotentialNotes) tooltipDetails.push(`Market Potential: ${company.MarketPotentialNotes}`); if (company.SynergiesNotes) tooltipDetails.push(`Synergies: ${company.SynergiesNotes}`); if (company.ExitPotentialNotes) tooltipDetails.push(`Exit Potential: ${company.ExitPotentialNotes}`); row.setAttribute('title', tooltipDetails.join('\n')); const cells = [ company.rank !== undefined ? company.rank : 'N/A', company.CompanyName || 'N/A', company.score !== undefined ? formatNumber(company.score, 1) : 'N/A', company.ARR !== undefined ? formatCurrency(company.ARR) : 'N/A', company.RevenueGrowth !== undefined ? formatPercent(company.RevenueGrowth) : 'N/A', company.NRR !== undefined ? formatPercent(company.NRR) : 'N/A', company.GREM !== undefined ? formatPercent(company.GREM) : 'N/A', company.valuationRange ? formatValuation(company.valuationRange) : 'N/A' ]; cells.forEach(text => { const td = document.createElement('td'); td.textContent = text; row.appendChild(td); }); tbody.appendChild(row); } catch (rowError) { console.error(`DEBUG: Error processing row ${index+1} for company "${company?.CompanyName || 'Unknown'}" in displayResults:`, rowError); logError(`Error displaying row for company "${company?.CompanyName || 'Unknown'}". Check console.`, true); } }); table.appendChild(thead); table.appendChild(tbody); resultsTableContainer.appendChild(table); console.log("DEBUG: Results table added to DOM."); }

        // --- Sample CSV Generation (Uses expected IDs in header) ---
        function generateSampleCSV() {
            console.log("DEBUG: Generating sample CSV...");
            try {
                const header = expectedColumns.join(','); // Use the required internal IDs
                const rows = [
                    // Using original IDs like VerticalFocusScore, LeadershipScore, etc.
                    '"Alpha Solutions",5000000,0.15,0.60,1.15,0.92,0.08,4.5,8,7,9,8,7,9,8,7,8,3,"https://alpha.com","CRM for Renewable Energy Sector, specialized modules","Alice Alpha","https://linkedin.com/in/alicealpha","High growth in target vertical, potential for geographic expansion.","Strong fit with Evident\'s sustainability focus, data integration possible.","Good candidate for PE exit or strategic acquisition by energy player in 3-5 years."',
                    '"Beta Software Inc.",2000000,0.05,0.30,0.98,0.85,0.18,3.1,6,6,5,7,6,7,7,5,7,5,"https://beta.inc","Project Management Tool, horizontal focus with SMB niche","Bob Beta","https://linkedin.com/in/bobbeta","Large but competitive market. Needs stronger differentiation strategy.","Limited immediate product synergy, potential for incorporating into broader suite later.","Likely smaller exit, maybe tuck-in acquisition by larger PM vendor." ',
                    '"Gamma Tech",800000,-0.10,0.90,1.05,0.90,0.05,2.5,7,8,8,6,8,6,6,4,6,2,"https://gamma.tech","Niche AI analytics for scientific research data","","", "Untapped niche with high value potential if tech is validated. High risk.", "Potential data/AI synergy if tech is robust and applicable elsewhere. Needs diligence.", "Binary outcome: could be valuable IP acquisition or limited interest if tech doesn\'t scale." '
                ];
                const csvContent = header + '\n' + rows.join('\n');
                if(csvSampleContainer) {
                    csvSampleContainer.textContent = csvContent;
                } else {
                    console.warn("DEBUG: csvSampleContainer not found, cannot display sample CSV.");
                }
                console.log("DEBUG: Sample CSV display attempted.");
            } catch(error) {
                console.error("DEBUG: Error generating sample CSV:", error);
                logError("Failed to generate sample CSV display.", true);
            }
        }

        // --- Initial setup (Safer execution) ---
        function runInitialSetup() {
            console.log("DEBUG: runInitialSetup entered.");
            try {
                console.log("DEBUG: Adding event listeners...");
                if (csvFileInput) csvFileInput.addEventListener('change', handleFileSelect, false); else console.error("DEBUG: csvFileInput not found!");
                if (analyzeButton) analyzeButton.addEventListener('click', runAnalysis); else console.error("DEBUG: analyzeButton not found!");
                console.log("DEBUG: Event listeners added.");
            } catch (listenerError) {
                console.error("DEBUG: Error adding event listeners:", listenerError);
                logError("Critical Error: Failed to set up interaction listeners.", true);
                return; // Stop if listeners fail
            }

            try {
                console.log("DEBUG: Attempting generateSampleCSV()...");
                generateSampleCSV();
                console.log("DEBUG: generateSampleCSV() finished.");
            } catch(error) {
                console.error("DEBUG: Error during generateSampleCSV call:", error);
                logError("Error generating sample CSV.", true);
            }

            try {
                console.log("DEBUG: Attempting initializeSliders()...");
                initializeSliders();
                console.log("DEBUG: initializeSliders() finished.");
            } catch(error) {
                console.error("DEBUG: Error during initializeSliders call:", error);
                logError("Critical Error: Failed to initialize sliders.", true);
            }
            console.log("DEBUG: Initial script setup complete.");
        }

        // Use DOMContentLoaded to ensure elements exist before running setup
        if (document.readyState === 'loading') { // Loading hasn't finished yet
             document.addEventListener('DOMContentLoaded', runInitialSetup);
         } else { // `DOMContentLoaded` has already fired
             console.log("DEBUG: DOM already loaded, running initial setup immediately.");
             runInitialSetup();
         }

    } catch (globalError) {
        // Catch any error that might happen during initial script parsing/execution
        console.error("DEBUG: GLOBAL JAVASCRIPT ERROR:", globalError);
        // Try to display a critical error message to the user
        const errorDiv = document.getElementById('error-log');
        if (errorDiv) {
            errorDiv.innerHTML = '<p style="color:red; font-weight:bold;">CRITICAL SCRIPT ERROR: Tool failed to initialize. Check browser console (F12) for details.</p>';
        }
        // Also alert, as UI might be broken
        alert("CRITICAL SCRIPT ERROR: Tool failed to initialize. Check browser console (F12) for details. Message: " + globalError.message);
    }
    </script>

</body>
</html>
